#!/usr/bin/env python3
"""
- Script that reads bram via uart from a xilinx fpga.
- Is supposed to be used in combination with uart bram implementation in (TODO link)
- second version: no header, defined start command, CRC
"""

import pyftdi.serialext
import pyftdi.ftdi
import serial
import argparse
import os
import sys
import time

from contextlib import ExitStack
from pathlib import Path

from typing import Tuple, List, Any


def create_parser() -> argparse.ArgumentParser:

    parser = argparse.ArgumentParser(
        description="Script that reads bram data via UART and does some evalutation on it."
    )
    parser.add_argument(
        "-d", "--device", help="Serial number of device.", default="210183A89AC3"
    )
    parser.add_argument(
        "-s",
        "--show_device",
        help="Show currently connected ftdi devices. NOTE: Devices occupied by Vivados Hardware Manager may not be available.",
        required=False,
        action="store_true",
    )
    parser.add_argument(
        "-o", "--output_path", help="Path where read output files shall be saved"
    )
    parser.add_argument(
        "-b", "--baudrate", 
        help="Baudrate sued by UART on FPGA",
        required=False,
        default=1e6
    )
    parser.add_argument(
        "-i", "--ftdi_interface",
        help="Some ftdi chips have multiple interfaces. Specify the index if needed. "
        "(Digilents UART Adapters use interface 1)",
        required=False,
        type=int,
        default=1
    )
    parser.add_argument(
        "-l", "--failure_limit",
        help="The UART may fail sometimes due to unknown reasons. "
        "The script will then attempt to restart the measurement. "
        "This parameter determines the number of failed attempts before the script crashes.",
        default=10,
        required=False,
        type=int
    )
    return parser
# Start byte/ byte swap?
#


# dev =  pyftdi.ftdi.Ftdi.list_devices()
# ftdi://ftdi:2232:210183A89AC3/2 -> Basys3
# ftdi://ftdi:2232:210279651642/2 -> Zybo


def evaluate_readout(data: str, previous_value: str) -> List[Tuple[str, int]]:
    if len(previous_value) != 2:
        raise Exception("Wrong length of expected data. Please enter two hex digits")
    return [
        (data[i : i + 2], i / 2)
        for i in range(0, len(data), 2)
        if data[i : i + 2] != previous_value
    ]


def start_transmission(port) -> Tuple[bytes, bytes]:
    # Write 's' to start  transfer
    port.write(b"s")
    port.flush()



def get_crc(crc_prev, data):
    """Compute CRC

    Generated by https://bues.ch/cms/hacking/crcgen:
     CRC polynomial coefficients: x^4 + x^2 + x + 1
                                  0xE (hex)
     CRC width:                   4 bits
     CRC shift direction:         right (little endian)
     Input word width:            36 bits
    """
    class bitwrapper:
        def __init__(self, x):
            self.x = x
        def __getitem__(self, i):
            return (self.x[i//8] >> (i%8)) & 1
        def __setitem__(self, i, x):
            #self.x = (self.x | (1 << i)) if x else (self.x & ~(1 << i))
            self.x = self.x[:i//8] + ((self.x[i//8] | (1 << i)) if x else (self.x[i//8] & ~(1 << i))).to_bytes(1, "big") + self.x[i//8+1:]
    
    crc_prev = bitwrapper(crc_prev)
    data = bitwrapper(data)
    ret = bitwrapper(b"\x00")
    
    ret[0] = crc_prev[1] ^ data[1] ^ data[5] ^ data[6] ^ data[8] ^ data[12] ^ data[13] ^ data[15] ^ data[19] ^ data[20] ^ data[22] ^ data[26] ^ data[27] ^ data[29] ^ data[33] ^ data[34]
    ret[1] = crc_prev[0] ^ crc_prev[2] ^ data[0] ^ data[2] ^ data[6] ^ data[7] ^ data[9] ^ data[13] ^ data[14] ^ data[16] ^ data[20] ^ data[21] ^ data[23] ^ data[27] ^ data[28] ^ data[30] ^ data[34] ^ data[35]
    ret[2] = crc_prev[0] ^ crc_prev[3] ^ data[0] ^ data[3] ^ data[5] ^ data[6] ^ data[7] ^ data[10] ^ data[12] ^ data[13] ^ data[14] ^ data[17] ^ data[19] ^ data[20] ^ data[21] ^ data[24] ^ data[26] ^ data[27] ^ data[28] ^ data[31] ^ data[33] ^ data[34] ^ data[35]
    ret[3] = crc_prev[0] ^ data[0] ^ data[4] ^ data[5] ^ data[7] ^ data[11] ^ data[12] ^ data[14] ^ data[18] ^ data[19] ^ data[21] ^ data[25] ^ data[26] ^ data[28] ^ data[32] ^ data[33] ^ data[35]
    return ret.x



def process_batch(batch, prev_crc) -> Tuple[bytes, bytes, bytes]:
    tmp = batch[4]
    data = batch[:4]
    
    parity = (tmp & 0xF).to_bytes(1, "big")
    sent_crc = (tmp >> 4).to_bytes(1, "big")

    crc = get_crc(prev_crc, data+parity)
    if sent_crc != crc:
        raise Exception(f"Error: mismatched CRC: 0x{crc[0]:02x} != 0x{sent_crc[0]:02x}")
    
    return data, parity, crc


def read_data(port, count) -> bytes:
    todo = count
    data = []
    
    last_time = None

    while todo > 0:
        part = port.read(min(todo, 4096))
        data.append(part)
        todo -= len(part)

        if last_time is None and len(part) == 0:
            last_time = time.time()
            current_time = time.time()
        elif len(part) == 0:
            current_time = time.time()
            if current_time - last_time > 1:
                print("UART failure: stopping batch")
                raise Exception
        else:
            last_time = None
    
    return b"".join(data)


def prepare_paths(input_path: str) -> Tuple[Path, Path]:
    """
    Expects path of form: .../1
    Returns: (.../data_reads/1, .../parity_reads/1
    """
    given_path = Path(input_path)
    base_path = Path(*given_path.parts[:-1])
    new_paths = (Path(base_path, "data_reads"), Path(base_path, "parity_reads"))

    file_name = given_path.parts[-1]
    for path in new_paths:
        if path.exists():
            continue
        else:
            path.mkdir(parents=True)

    return (Path(path, file_name) for path in new_paths)

def read_content(args: Any) -> None:
    with ExitStack() as stack:
        # port = pyftdi.serialext.serial_for_url('ftdi://ftdi:2232:210183A89AC3/2 ', baudrate=9600, parity=serial.PARITY_EVEN)
        interface = args["ftdi_interface"]
        print(interface)
        port = pyftdi.serialext.serial_for_url(
                f'ftdi://ftdi:232r:{args["device"]}/{interface}',
                baudrate=args["baudrate"],
                parity=serial.PARITY_NONE,
                timeout=0,
            )
        #print(port)
        stack.enter_context(port)
        port.reset_input_buffer()
        port.reset_output_buffer()
        #print(port)
        
        start_transmission(port)
        goal = (4+1)*1024
        #print("awaiting data")
        
        raw_data = read_data(port, goal)
        

        if len(raw_data) != goal:
            raise Exception(f"{len(raw_data)} from {goal} received")
        #print("Got data")
        
        crc = b'\x00'
        data = b""
        parity = ""
        for k, batch in enumerate([raw_data[i:i+5]for i in range(0, len(raw_data), 5)]):
            temp_data, temp_parity, crc = process_batch(batch, crc)
            #print(k, "received", temp_data, temp_parity, crc)

            data += temp_data
            parity += temp_parity.hex()[1]

        if args["output_path"] is not None:
            data_path, parity_path = prepare_paths(args["output_path"])
            print(data_path)
            with open(data_path, mode="wb") as f:
                f.write(data)
            with open(parity_path, mode="wb") as f:
                f.write(bytes.fromhex(parity))


def main(args: Any) -> None:
        

        if args["show_device"]:
            devices = pyftdi.ftdi.Ftdi.list_devices()
            print("Devices:")
            for dev in devices:
                print(f"\t{dev[0].description}: {dev[0].sn}")
            exit(0)

        failure_counter = 0
        if args["device"] is not None:

            while True:
                try:
                    read_content(args)
                    break

                except Exception:
                    failure_counter += 1
                    if failure_counter > args["failure_limit"]:
                        raise Exception(
                            "UART failed too many times. Aborting readout"
                        )
        else:
            print(
                "No Serial Number specified. Call with '-s' to see possible serial numbers."
            )



if __name__ == "__main__":
    argparser = create_parser()
    args = vars(argparser.parse_args())
    main(args)
   