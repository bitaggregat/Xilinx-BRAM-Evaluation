module read_bram
#(
	parameter TICKS_PER_BIT = 133 //400e6/3e6
)
(
    input clk_i,
    input uart_rx_i,
    output uart_tx_o,
    output [7:0] led_o
);
    
    localparam STATE_WAIT_RX = 4'b0000;
    localparam STATE_SEND_0 = 4'b0001;
    localparam STATE_WAIT_0 = 4'b0011;
    localparam STATE_SEND_1 = 4'b0010;
    localparam STATE_WAIT_1 = 4'b0110;
    localparam STATE_SEND_2 = 4'b0111;
    localparam STATE_WAIT_2 = 4'b0101;
    localparam STATE_SEND_3 = 4'b0100;
    localparam STATE_WAIT_3 = 4'b1100;
    localparam STATE_SEND_PAR = 4'b1101;
    localparam STATE_WAIT_PAR = 4'b1111;
    
    reg [3:0] state = STATE_WAIT_RX, next_state = STATE_WAIT_RX;
    reg tx_start;
    reg [7:0] tx_data;
    reg [35:0] batch_data;
    reg [9:0] bram_addr;
    reg [3:0] crc;
    
    wire fast_clk;
    wire [7:0] rx_data;
    wire rx_done;
    wire tx_done;
    wire [35:0] bram_data;
    
    //assign fast_clk = clk_i;
    assign led_o = 8'h00;
    
    // state transition
    always @(posedge fast_clk)
    begin
        state <= next_state;
    end
    
    // determine next state
    always @(*)
    begin
        next_state = 4'hx;
        case(state)
        STATE_WAIT_RX:
            if (rx_done && rx_data==8'h73)// received 's'
                next_state = STATE_SEND_0;
            else
                next_state = STATE_WAIT_RX;
        STATE_SEND_0:
            next_state = STATE_WAIT_0;
        STATE_WAIT_0:
            if (tx_done)
                next_state = STATE_SEND_1;
            else
                next_state = STATE_WAIT_0;
        STATE_SEND_1:
            next_state = STATE_WAIT_1;
        STATE_WAIT_1:
            if (tx_done)
                next_state = STATE_SEND_2;
            else
                next_state = STATE_WAIT_1;
        STATE_SEND_2:
            next_state = STATE_WAIT_2;
        STATE_WAIT_2:
            if (tx_done)
                next_state = STATE_SEND_3;
            else
                next_state = STATE_WAIT_2;
        STATE_SEND_3:
            next_state = STATE_WAIT_3;
        STATE_WAIT_3:
            if (tx_done)
                next_state = STATE_SEND_PAR;
            else
                next_state = STATE_WAIT_3;
        STATE_SEND_PAR:
            next_state = STATE_WAIT_PAR;
        STATE_WAIT_PAR:
            if (tx_done)
            begin
                if (bram_addr == 10'h0)
                    next_state = STATE_WAIT_RX;
                else
                    next_state = STATE_SEND_0;
            end
            else
                next_state = STATE_WAIT_PAR;
        endcase
    end
    
    // determine output
    always @(posedge fast_clk)
    begin
        tx_data <= tx_data;
        tx_start <= 1'b0;
        bram_addr <= bram_addr;
        batch_data <= batch_data;
        crc <= crc;
        case(next_state)
        STATE_WAIT_RX:
        begin
            bram_addr <= 10'h0;
            crc <= 4'h0;
        end
        STATE_WAIT_0, STATE_WAIT_1, STATE_WAIT_2, STATE_WAIT_3, STATE_WAIT_PAR:
            ; // defaults
        STATE_SEND_0:
        begin
            batch_data <= bram_data;
            tx_data <= bram_data[7:0];
            tx_start <= 1'b1;
            bram_addr <= bram_addr + 1;
        end
        STATE_SEND_1:
        begin
            tx_data <= batch_data[15:8];
            tx_start <= 1'b1;
            // generated by https://bues.ch/cms/hacking/crcgen
            // with CRC width 4 bits, data width 36
            crc[0] <= batch_data[1] ^ batch_data[5] ^ batch_data[6] ^ batch_data[8] ^ batch_data[12] ^ batch_data[13] ^ batch_data[15] ^ batch_data[19] ^ batch_data[20] ^ batch_data[22] ^ batch_data[26] ^ batch_data[27] ^ batch_data[29] ^ batch_data[33] ^ batch_data[34] ^ crc[1];
            crc[1] <= batch_data[0] ^ batch_data[2] ^ batch_data[6] ^ batch_data[7] ^ batch_data[9] ^ batch_data[13] ^ batch_data[14] ^ batch_data[16] ^ batch_data[20] ^ batch_data[21] ^ batch_data[23] ^ batch_data[27] ^ batch_data[28] ^ batch_data[30] ^ batch_data[34] ^ batch_data[35] ^ crc[0] ^ crc[2];
            crc[2] <= batch_data[0] ^ batch_data[3] ^ batch_data[5] ^ batch_data[6] ^ batch_data[7] ^ batch_data[10] ^ batch_data[12] ^ batch_data[13] ^ batch_data[14] ^ batch_data[17] ^ batch_data[19] ^ batch_data[20] ^ batch_data[21] ^ batch_data[24] ^ batch_data[26] ^ batch_data[27] ^ batch_data[28] ^ batch_data[31] ^ batch_data[33] ^ batch_data[34] ^ batch_data[35] ^ crc[0] ^ crc[3];
            crc[3] <= batch_data[0] ^ batch_data[4] ^ batch_data[5] ^ batch_data[7] ^ batch_data[11] ^ batch_data[12] ^ batch_data[14] ^ batch_data[18] ^ batch_data[19] ^ batch_data[21] ^ batch_data[25] ^ batch_data[26] ^ batch_data[28] ^ batch_data[32] ^ batch_data[33] ^ batch_data[35] ^ crc[0];
        end
        STATE_SEND_2:
        begin
            tx_data <= batch_data[23:16];
            tx_start <= 1'b1;
        end
        STATE_SEND_3:
        begin
            tx_data <= batch_data[31:24];
            tx_start <= 1'b1;
        end
        STATE_SEND_PAR:
        begin
            tx_data <= {crc, batch_data[35:32]};
            tx_start <= 1'b1;
        end
        endcase
    end
    
    clk_wiz_0 clock
    (
        .clk_out1(fast_clk),
        .clk_in1(clk_i)
    );
    
    uart_rx
    #(
        .CLK_PER_BIT(TICKS_PER_BIT)
    ) rx (
        .clk(fast_clk),
        .rx(uart_rx_i),
        .data(rx_data),
        .rx_done(rx_done)
    );
    
    uart_tx
    #(
        .CLK_PER_BIT(TICKS_PER_BIT)
    ) tx (
        .clk(fast_clk),
        .tx_start(tx_start),
        .data(tx_data),
        .tx_done(tx_done),
        .tx(uart_tx_o)
    );
    
    bram_read_test bram_wrap(
        .clka(fast_clk),
        .addra(bram_addr),
        .douta(bram_data) 
    );

endmodule