#!/usr/bin/env python3
"""
- Script that reads bram via uart from a xilinx fpga.
- Is supposed to be used in combination with uart bram implementation in (TODO link)
- second version: no header, defined start command, CRC
"""

import pyftdi.serialext
import pyftdi.ftdi
import serial
import argparse
import os
from pathlib import Path

from typing import Tuple, List

parser = argparse.ArgumentParser(
    description="Script that reads bram data via UART and does some evalutation on it."
)
parser.add_argument(
    "-d", "--device", help="Serial number of device.", default="210183A89AC3"
)
parser.add_argument(
    "-s",
    "--show_device",
    help="Show currently connected ftdi devices. NOTE: Devices occupied by Vivados Hardware Manager may not be available.",
    required=False,
    action="store_true",
)
parser.add_argument(
    "-v",
    "--previous_value",
    help="Value that was previously written to the BRAM (before it was depowered). Either ff or 00",
    default="00",
)
parser.add_argument(
    "-o", "--output_path", help="Path where read output files shall be saved"
)
# Start byte/ byte swap?
#


# dev =  pyftdi.ftdi.Ftdi.list_devices()
# ftdi://ftdi:2232:210183A89AC3/2 -> Basys3
# ftdi://ftdi:2232:210279651642/2 -> Zybo


def evaluate_readout(data: str, previous_value: str) -> List[Tuple[str, int]]:
    if len(previous_value) != 2:
        raise Exception("Wrong length of expected data. Please enter two hex digits")
    return [
        (data[i : i + 2], i / 2)
        for i in range(0, len(data), 2)
        if data[i : i + 2] != previous_value
    ]


def find_transmission_start(port) -> Tuple[bytes, bytes]:
    # Write 's' to start  transfer
    port.write(b"s")


def get_crc(crc_prev, data):
    """Compute CRC

    Generated by https://bues.ch/cms/hacking/crcgen:
     CRC polynomial coefficients: x^4 + x^2 + x + 1
                                  0xE (hex)
     CRC width:                   4 bits
     CRC shift direction:         right (little endian)
     Input word width:            36 bits
    """
    class bitwrapper:
        def __init__(self, x):
            self.x = x
        def __getitem__(self, i):
            return (self.x[i//8] >> (i%8)) & 1
        def __setitem__(self, i, x):
            #self.x = (self.x | (1 << i)) if x else (self.x & ~(1 << i))
            self.x = self.x[:i//8] + ((self.x[i//8] | (1 << i)) if x else (self.x[i//8] & ~(1 << i))).to_bytes() + self.x[i//8+1:]
    
    crc_prev = bitwrapper(crc_prev)
    data = bitwrapper(data)
    ret = bitwrapper(b"\x00")
    
    ret[0] = crc_prev[1] ^ data[1] ^ data[5] ^ data[6] ^ data[8] ^ data[12] ^ data[13] ^ data[15] ^ data[19] ^ data[20] ^ data[22] ^ data[26] ^ data[27] ^ data[29] ^ data[33] ^ data[34]
    ret[1] = crc_prev[0] ^ crc_prev[2] ^ data[0] ^ data[2] ^ data[6] ^ data[7] ^ data[9] ^ data[13] ^ data[14] ^ data[16] ^ data[20] ^ data[21] ^ data[23] ^ data[27] ^ data[28] ^ data[30] ^ data[34] ^ data[35]
    ret[2] = crc_prev[0] ^ crc_prev[3] ^ data[0] ^ data[3] ^ data[5] ^ data[6] ^ data[7] ^ data[10] ^ data[12] ^ data[13] ^ data[14] ^ data[17] ^ data[19] ^ data[20] ^ data[21] ^ data[24] ^ data[26] ^ data[27] ^ data[28] ^ data[31] ^ data[33] ^ data[34] ^ data[35]
    ret[3] = crc_prev[0] ^ data[0] ^ data[4] ^ data[5] ^ data[7] ^ data[11] ^ data[12] ^ data[14] ^ data[18] ^ data[19] ^ data[21] ^ data[25] ^ data[26] ^ data[28] ^ data[32] ^ data[33] ^ data[35]
    return ret.x

def read_batch(port, prev_crc) -> Tuple[bytes, bytes, bytes]:
    data = port.read(4)
    tmp = port.read(1)[0]
    
    parity = (tmp & 0xF).to_bytes()
    send_crc = (tmp >> 4).to_bytes()
    
    crc = get_crc(prev_crc, data+parity)
    
    return data, parity, crc


def prepare_paths(input_path: str) -> Tuple[Path, Path]:
    """
    Expects path of form: .../1
    Returns: (.../data_reads/1, .../parity_reads/1
    """
    given_path = Path(input_path)
    base_path = Path(*given_path.parts[:-1])
    new_paths = (Path(base_path, "data_reads"), Path(base_path, "parity_reads"))

    file_name = given_path.parts[-1]
    for path in new_paths:
        if path.exists():
            continue
        else:
            path.mkdir(parents=True)

    return (Path(path, file_name) for path in new_paths)


if __name__ == "__main__":
    args = vars(parser.parse_args())

    if args["show_device"]:
        devices = pyftdi.ftdi.Ftdi.list_devices()
        print("Devices:")
        for dev in devices:
            print(f"\t{dev[0].description}: {dev[0].sn}")
        exit(0)

    if args["device"] is not None:
        # port = pyftdi.serialext.serial_for_url('ftdi://ftdi:2232:210183A89AC3/2 ', baudrate=9600, parity=serial.PARITY_EVEN)
        if args["device"] in ["A503VSXV", "A503VYYY", "A503VSBM"]:
            # This specific UART Adapter uses a different ftdi chip and port than dev boards
            # Making this more 'generic' could be a future TODO
            port = pyftdi.serialext.serial_for_url(
                f'ftdi://ftdi:232r:{args["device"]}/1',
                baudrate=115200,
                parity=serial.PARITY_NONE,
            )
        else:
            port = pyftdi.serialext.serial_for_url(
                f'ftdi://ftdi:2232:{args["device"]}/2',
                baudrate=115200,
                parity=serial.PARITY_NONE,
            )
        
        find_transmission_start(port)
        data = b""
        parity = ""
        crc = b'\x00'
        for _ in range(1024):
            temp_data, temp_parity, crc = read_batch(port, crc)

            data += temp_data
            parity += temp_parity.hex()[1]

        parity = "".join([parity[i + 1] + parity[i] for i in range(0, len(parity), 2)])

        if args["output_path"] is not None:
            data_path, parity_path = prepare_paths(args["output_path"])

            with open(data_path, mode="wb") as f:
                f.write(data)
            with open(parity_path, mode="wb") as f:
                f.write(bytes.fromhex(parity))

    else:
        print(
            "No Serial Number specified. Call with '-s' to see possible serial numbers."
        )
