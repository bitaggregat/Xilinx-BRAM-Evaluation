#!/usr/bin/env python3
"""
- Script that reads bram via uart from a xilinx fpga.
- Is supposed to be used in combination with uart bram implementation in (TODO link)
- second version: no header, defined start command, CRC
"""

import pyftdi.serialext
import pyftdi.ftdi
import serial
import argparse
import os
import sys

from contextlib import ExitStack
from pathlib import Path

from typing import Tuple, List

parser = argparse.ArgumentParser(
    description="Script that reads bram data via UART and does some evalutation on it."
)
parser.add_argument(
    "-d", "--device", help="Serial number of device.", default="210183A89AC3"
)
parser.add_argument(
    "-s",
    "--show_device",
    help="Show currently connected ftdi devices. NOTE: Devices occupied by Vivados Hardware Manager may not be available.",
    required=False,
    action="store_true",
)
parser.add_argument(
    "-v",
    "--previous_value",
    help="Value that was previously written to the BRAM (before it was depowered). Either ff or 00",
    default="00",
)
parser.add_argument(
    "-o", "--output_path", help="Path where read output files shall be saved"
)
# Start byte/ byte swap?
#


# dev =  pyftdi.ftdi.Ftdi.list_devices()
# ftdi://ftdi:2232:210183A89AC3/2 -> Basys3
# ftdi://ftdi:2232:210279651642/2 -> Zybo


def evaluate_readout(data: str, previous_value: str) -> List[Tuple[str, int]]:
    if len(previous_value) != 2:
        raise Exception("Wrong length of expected data. Please enter two hex digits")
    return [
        (data[i : i + 2], i / 2)
        for i in range(0, len(data), 2)
        if data[i : i + 2] != previous_value
    ]


def find_transmission_start(port) -> Tuple[bytes, bytes]:
    # Write 's' to start  transfer
    port.write(b"s")
    port.flush()


def get_crc(crc_prev, data):
    """Compute CRC

    Generated by https://bues.ch/cms/hacking/crcgen:
     CRC polynomial coefficients: x^4 + x^2 + x + 1
                                  0xE (hex)
     CRC width:                   4 bits
     CRC shift direction:         right (little endian)
     Input word width:            36 bits
    """
    class bitwrapper:
        def __init__(self, x):
            self.x = x
        def __getitem__(self, i):
            return (self.x[i//8] >> (i%8)) & 1
        def __setitem__(self, i, x):
            #self.x = (self.x | (1 << i)) if x else (self.x & ~(1 << i))
            self.x = self.x[:i//8] + ((self.x[i//8] | (1 << i)) if x else (self.x[i//8] & ~(1 << i))).to_bytes() + self.x[i//8+1:]
    
    crc_prev = bitwrapper(crc_prev)
    data = bitwrapper(data)
    ret = bitwrapper(b"\x00")
    
    ret[0] = crc_prev[1] ^ data[1] ^ data[5] ^ data[6] ^ data[8] ^ data[12] ^ data[13] ^ data[15] ^ data[19] ^ data[20] ^ data[22] ^ data[26] ^ data[27] ^ data[29] ^ data[33] ^ data[34]
    ret[1] = crc_prev[0] ^ crc_prev[2] ^ data[0] ^ data[2] ^ data[6] ^ data[7] ^ data[9] ^ data[13] ^ data[14] ^ data[16] ^ data[20] ^ data[21] ^ data[23] ^ data[27] ^ data[28] ^ data[30] ^ data[34] ^ data[35]
    ret[2] = crc_prev[0] ^ crc_prev[3] ^ data[0] ^ data[3] ^ data[5] ^ data[6] ^ data[7] ^ data[10] ^ data[12] ^ data[13] ^ data[14] ^ data[17] ^ data[19] ^ data[20] ^ data[21] ^ data[24] ^ data[26] ^ data[27] ^ data[28] ^ data[31] ^ data[33] ^ data[34] ^ data[35]
    ret[3] = crc_prev[0] ^ data[0] ^ data[4] ^ data[5] ^ data[7] ^ data[11] ^ data[12] ^ data[14] ^ data[18] ^ data[19] ^ data[21] ^ data[25] ^ data[26] ^ data[28] ^ data[32] ^ data[33] ^ data[35]
    return ret.x


def read_batch(port, prev_crc) -> Tuple[bytes, bytes, bytes]:
    batch = port.read(5)
    if len(data) != 5:
        raise Exception(f"Received {data}, but expected 5 bytes")
    return process_batch(batch, prev_crc)


def process_batch(batch, prev_crc) -> Tuple[bytes, bytes, bytes]:
    tmp = batch[4]
    data = batch[:4]
    
    parity = (tmp & 0xF).to_bytes()
    sent_crc = (tmp >> 4).to_bytes()
    
    crc = get_crc(prev_crc, data+parity)
    if sent_crc != crc:
        print(f"Warning: mismatched CRC: 0x{crc[0]:02x} != 0x{sent_crc[0]:02x}")
    
    return data, parity, crc


def read_data(port, count) -> bytes:
    todo = count
    data = []
    
    while todo > 0:
        part = port.read(min(todo, 4096))
        data.append(part)
        todo -= len(part)
    
    return b"".join(data)


def prepare_paths(input_path: str) -> Tuple[Path, Path]:
    """
    Expects path of form: .../1
    Returns: (.../data_reads/1, .../parity_reads/1
    """
    given_path = Path(input_path)
    base_path = Path(*given_path.parts[:-1])
    new_paths = (Path(base_path, "data_reads"), Path(base_path, "parity_reads"))

    file_name = given_path.parts[-1]
    for path in new_paths:
        if path.exists():
            continue
        else:
            path.mkdir(parents=True)

    return (Path(path, file_name) for path in new_paths)


if __name__ == "__main__":
    args = vars(parser.parse_args())

    if args["show_device"]:
        devices = pyftdi.ftdi.Ftdi.list_devices()
        print("Devices:")
        for dev in devices:
            print(f"\t{dev[0].description}: {dev[0].sn}")
        exit(0)

    baudrate = 3000000
    if args["device"] is not None:
        with ExitStack() as stack:
            # port = pyftdi.serialext.serial_for_url('ftdi://ftdi:2232:210183A89AC3/2 ', baudrate=9600, parity=serial.PARITY_EVEN)
            if args["device"] in ["A503VSXV", "A503VYYY", "A503VSBM", "A801TJLF"]:
                # This specific UART Adapter uses a different ftdi chip and port than dev boards
                # Making this more 'generic' could be a future TODO
                port = pyftdi.serialext.serial_for_url(
                    f'ftdi://ftdi:232r:{args["device"]}/1',
                    baudrate=baudrate,
                    parity=serial.PARITY_NONE,
                    timeout=0,
                )
            else:
                port = pyftdi.serialext.serial_for_url(
                    f'ftdi://ftdi:2232:{args["device"]}/2',
                    baudrate=baudrate,
                    parity=serial.PARITY_NONE,
                )
            print(port)
            stack.enter_context(port)
            port.reset_input_buffer()
            port.reset_output_buffer()
            #print(port)
            
            find_transmission_start(port)
            goal = (4+1)*1024
            raw_data = read_data(port, goal)
            if len(raw_data) != goal:
                raise Excption(f"{len(data)} from {goal} received")
            
            crc = b'\x00'
            data = b""
            parity = ""
            for k, batch in enumerate([raw_data[i:i+5]for i in range(0, len(raw_data), 5)]):
                temp_data, temp_parity, crc = process_batch(batch, crc)
                print(k, "received", temp_data, temp_parity, crc)

                data += temp_data
                parity += temp_parity.hex()[1]

            parity = "".join([parity[i + 1] + parity[i] for i in range(0, len(parity), 2)])

            if args["output_path"] is not None:
                data_path, parity_path = prepare_paths(args["output_path"])

                with open(data_path, mode="wb") as f:
                    f.write(data)
                with open(parity_path, mode="wb") as f:
                    f.write(bytes.fromhex(parity))
            
    else:
        print(
            "No Serial Number specified. Call with '-s' to see possible serial numbers."
        )
